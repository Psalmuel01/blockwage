// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/**
 * @title PaymentVerifier
 * @dev Minimal on-chain verifier & replay-prevention registry for facilitator (x402) payment proofs.
 *
 * This contract is intentionally conservative and acts as a stubbed-but-functional verifier:
 * - Accepts a raw `facilitatorProof` blob (off-chain generated by facilitator flow).
 * - Parses the blob for `employee` and `periodId` (expected layout described below).
 * - Records a mapping marking (employee, periodId) as verified to prevent double-pay.
 * - Exposes `isVerified(employee, periodId)` to be used by `PayrollVault`.
 *
 * IMPORTANT:
 * - This contract does not (and cannot, on its own) validate external facilitator signatures
 *   or off-chain receipts without on-chain oracle data from the facilitator service.
 * - For production usage you must integrate a trusted oracle or an on-chain attestation from
 *   the facilitator backend. This contract is structured so such logic can be added later.
 *
 * Proof encoding (expected):
 *   abi.encodePacked(employeeAddress (20 bytes) | periodId (32 bytes) | amount (32 bytes) | extra...)
 *
 * The contract will read at least first 20 + 32 + 32 = 84 bytes from the proof and ignore trailing bytes.
 *
 * Access model:
 *   - Anyone may submit a proof via `verifyPayment(bytes calldata)` to register a verified payment if it
 *     satisfies basic checks and is not a replay. This is useful for automated schedulers / facilitator callbacks.
 *   - Owner (payroll admin) can revoke verifications in emergencies.
 */

import "@openzeppelin/contracts/access/Ownable.sol";

abstract contract PaymentVerifier is Ownable {
    // mapping employee => periodId => verified
    mapping(address => mapping(uint256 => bool)) private _verified;

    // mapping of raw proof hash => bool (prevent submitting same raw proof multiple times)
    mapping(bytes32 => bool) private _proofSeen;

    event PaymentVerified(
        address indexed employee,
        uint256 indexed periodId,
        uint256 amount,
        bytes32 proofHash,
        address indexed submitter
    );
    event PaymentRejected(
        address indexed submitter,
        bytes32 proofHash,
        string reason
    );
    event VerificationRevoked(
        address indexed employee,
        uint256 indexed periodId,
        address indexed admin
    );

    /**
     * @notice Verify a facilitator proof and mark (employee, periodId) as verified.
     * @param facilitatorProof Raw proof bytes produced by the facilitator off-chain flow.
     * @return ok True if verification succeeded and state was recorded; false otherwise.
     *
     * Decoding expectations (first 84 bytes):
     *  - bytes[0:20]   => employee address (left-padded in 32-byte word when read with calldataload)
     *  - bytes[20:52]  => periodId (uint256)
     *  - bytes[52:84]  => amount (uint256)
     *
     * Note: This implementation only performs structural parsing + replay protection and basic sanity checks.
     * Replace or extend with cryptographic verification against facilitator attestation for production.
     */
    function verifyPayment(
        bytes calldata facilitatorProof
    ) external returns (bool) {
        bytes32 proofHash = keccak256(facilitatorProof);

        if (_proofSeen[proofHash]) {
            emit PaymentRejected(msg.sender, proofHash, "proof-already-seen");
            return false;
        }

        // Minimum length check: 20 (addr) + 32 (periodId) + 32 (amount) = 84
        if (facilitatorProof.length < 84) {
            emit PaymentRejected(msg.sender, proofHash, "proof-too-short");
            return false;
        }

        address employee;
        uint256 periodId;
        uint256 amount;

        // Parse bytes directly from calldata for gas efficiency
        assembly {
            // pointer to start of facilitatorProof in calldata
            let ptr := add(facilitatorProof.offset, 0)

            // load 32 bytes at ptr (contains 12 bytes padding + 20 bytes address)
            let word := calldataload(ptr)
            // shift right 96 bits to keep lower 20 bytes as address
            employee := shr(96, word)

            // load periodId at offset ptr + 20
            periodId := calldataload(add(ptr, 20))

            // load amount at offset ptr + 52 (20 + 32)
            amount := calldataload(add(ptr, 52))
        }

        // Basic sanity checks
        if (employee == address(0)) {
            emit PaymentRejected(msg.sender, proofHash, "employee-zero");
            return false;
        }
        if (periodId == 0) {
            emit PaymentRejected(msg.sender, proofHash, "periodid-zero");
            return false;
        }
        if (amount == 0) {
            emit PaymentRejected(msg.sender, proofHash, "amount-zero");
            return false;
        }

        // Prevent double verification for same employee/period
        if (_verified[employee][periodId]) {
            emit PaymentRejected(
                msg.sender,
                proofHash,
                "employee-period-already-verified"
            );
            // still mark proof seen to prevent repeated submissions of same invalid proof
            _proofSeen[proofHash] = true;
            return false;
        }

        // NOTE: Here is where you would plug in cryptographic checks against facilitator-signed data,
        // merkle proofs, or an oracle query. Since that is off-chain and out-of-scope for this stub,
        // we treat structural validity as acceptance.
        // The design keeps proofHash and verified mappings so a later oracle/attestation system
        // can be used to upgrade trust before allowing PayrollVault to act.

        // Mark verified and record proof seen
        _verified[employee][periodId] = true;
        _proofSeen[proofHash] = true;

        emit PaymentVerified(employee, periodId, amount, proofHash, msg.sender);
        return true;
    }

    /**
     * @notice Check whether a given (employee, periodId) has been verified.
     * @param employee Employee address.
     * @param periodId Period identifier.
     * @return True if verified.
     */
    function isVerified(
        address employee,
        uint256 periodId
    ) external view returns (bool) {
        return _verified[employee][periodId];
    }

    /**
     * @notice Helper to check whether a raw proof has been seen before.
     */
    function proofSeen(bytes32 proofHash) external view returns (bool) {
        return _proofSeen[proofHash];
    }

    /**
     * @notice Emergency admin function to revoke a verification (for recovery/ops).
     * @dev Only callable by owner (payroll admin). Use with caution.
     */
    function revokeVerification(
        address employee,
        uint256 periodId
    ) external onlyOwner {
        require(_verified[employee][periodId], "not-verified");
        _verified[employee][periodId] = false;
        emit VerificationRevoked(employee, periodId, msg.sender);
    }

    /**
     * @notice Admin can mark a raw proof as seen (useful when proofs are consumed off-chain first).
     */
    function adminMarkProofSeen(bytes32 proofHash) external onlyOwner {
        _proofSeen[proofHash] = true;
    }

    /**
     * @notice Version tag for off-chain integration checks.
     */
    function version() external pure returns (string memory) {
        return "PaymentVerifier v0.1-stub";
    }
}
